{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.filterOptions = filterOptions;\nexports.typeaheadSimilarity = typeaheadSimilarity;\nexports.fullStringDistance = fullStringDistance;\nexports.cleanUpText = cleanUpText;\n/**\n * Filters React Select options and sorts by similarity to a search filter.\n * Handles partial matches, eg. searching for \"Waberg High\" will find \"Raoul\n * Wallenberg Traditional High School\". Case insensitive. Ignores\n * non-alphanumeric characters.\n *\n * @param  options  An unfiltered list of Options.\n * @param? filter  A string to compare against Option labels.\n * @param? substitutions  Strings with multiple spellings or variations that we\n *           expect to match, eg. accented characters or abbreviated words.\n *\n * @return A filtered and sorted array of Options.\n */\n\n/**\n * A collection of string matching algorithms built with React Select in mind.\n */\n// Option type from React Select and similar libraries.\n\nfunction filterOptions(options, filter, substitutions) {\n  // If the filter is blank, return the full list of Options.\n  if (!filter) {\n    return options;\n  }\n\n  var cleanFilter = cleanUpText(filter, substitutions);\n  return options // Filter out undefined or null Options.\n  .filter(function (_ref) {\n    var label = _ref.label,\n        value = _ref.value;\n    return label != null && value != null;\n  }) // Create a {score, Option} pair for each Option based on its label's\n  // similarity to the filter text.\n  .map(function (option) {\n    return {\n      option: option,\n      score: typeaheadSimilarity(cleanUpText(option.label, substitutions), cleanFilter)\n    };\n  }) // Only include matches of the entire substring, with a slight\n  // affordance for transposition or extra characters.\n  .filter(function (pair) {\n    return pair.score >= cleanFilter.length - 2;\n  }) // Sort 'em by order of their score.\n  .sort(function (a, b) {\n    return b.score - a.score;\n  }) // …and grab the original Options back from their pairs.\n  .map(function (pair) {\n    return pair.option;\n  });\n}\n/**\n * Scores the similarity between two strings by returning the length of the\n * longest common subsequence. Intended for comparing strings of different\n * lengths; eg. when matching a typeahead search input with a school name.\n\n * Meant for use in an instant search box where results are being fetched\n * as a user is typing.\n *\n * @param  a  The longer string (though, we flip them if it's shorter).\n * @param  b  The shorter string, eg. a typeahead search input.\n *\n * @return The length of the longest common subsequence. Higher scores indicate\n *           closer matches.\n */\n\n\nfunction typeaheadSimilarity(a, b) {\n  var aLength = a.length;\n  var bLength = b.length;\n  var table = [];\n\n  if (!aLength || !bLength) {\n    return 0;\n  } // Ensure `a` isn't shorter than `b`.\n\n\n  if (aLength < bLength) {\n    var _ref2 = [b, a];\n    a = _ref2[0];\n    b = _ref2[1];\n  } // Early exit if `a` includes `b`; these will be scored higher than any\n  // other options with the same `b` (filter string), with a preference for\n  // shorter `a` strings (option labels).\n\n\n  if (a.indexOf(b) !== -1) {\n    return bLength + 1 / aLength;\n  } // Initialize the table axes:\n  //\n  //    0 0 0 0 ... bLength\n  //    0\n  //    0\n  //\n  //   ...\n  //\n  // aLength\n  //\n\n\n  for (var x = 0; x <= aLength; ++x) {\n    table[x] = [0];\n  }\n\n  for (var y = 0; y <= bLength; ++y) {\n    table[0][y] = 0;\n  } // Populate the rest of the table with a dynamic programming algorithm.\n\n\n  for (var _x = 1; _x <= aLength; ++_x) {\n    for (var _y = 1; _y <= bLength; ++_y) {\n      table[_x][_y] = a[_x - 1] === b[_y - 1] ? 1 + table[_x - 1][_y - 1] : Math.max(table[_x][_y - 1], table[_x - 1][_y]);\n    }\n  }\n\n  return table[aLength][bLength];\n}\n/**\n * Returns the Levenshtein distance between two strings.\n *\n * NOTE: The Jaro-Winkler distance also worked well and is slightly more\n * performant. Levenshtein seems to match more reliably, which is more\n * important here.\n *\n * @param  a  The first string for comparison.\n * @param  b  The second string for comparison.\n *\n * @return The Levenshtein distance, where lower distance indicates higher\n *           similarity.\n */\n\n\nfunction fullStringDistance(a, b) {\n  var aLength = a.length;\n  var bLength = b.length;\n  var table = [];\n\n  if (!aLength) {\n    return bLength;\n  }\n\n  if (!bLength) {\n    return aLength;\n  } // Initialize the table axes:\n  //\n  //    0 1 2 3 4 ... bLength\n  //    1\n  //    2\n  //\n  //   ...\n  //\n  // aLength\n  //\n\n\n  for (var x = 0; x <= aLength; ++x) {\n    table[x] = [x];\n  }\n\n  for (var y = 0; y <= bLength; ++y) {\n    table[0][y] = y;\n  } // Populate the rest of the table with a dynamic programming algorithm.\n\n\n  for (var _x2 = 1; _x2 <= aLength; ++_x2) {\n    for (var _y2 = 1; _y2 <= bLength; ++_y2) {\n      table[_x2][_y2] = a[_x2 - 1] === b[_y2 - 1] ? table[_x2 - 1][_y2 - 1] : 1 + Math.min(table[_x2 - 1][_y2], // Substitution,\n      table[_x2][_y2 - 1], // insertion,\n      table[_x2 - 1][_y2 - 1]); // and deletion.\n    }\n  }\n\n  return table[aLength][bLength];\n}\n/**\n * Apply string substitutions, remove non-alphanumeric characters, and convert\n * all letters to uppercase.\n *\n * eg. 'Scoil Bhríde Primary School' may become 'SCOILBHRIDEPRIMARYSCHOOL'.\n *\n * @param  input  An unsanitized input string.\n * @param  substitutions  Strings with multiple spellings or variations that we\n *          expect to match, for example accented characters or abbreviated\n *          words.\n *\n * @return The sanitized text.\n */\n\n\nfunction cleanUpText(input, substitutions) {\n  if (!input) {\n    return '';\n  } // Uppercase and remove all non-alphanumeric, non-accented characters.\n  // Also remove underscores.\n\n\n  input = input.toUpperCase().replace(/((?=[^\\u00E0-\\u00FC])\\W)|_/g, '');\n\n  if (!substitutions) {\n    return input;\n  }\n\n  var safeSubstitutions = substitutions; // For Flow.\n  // Replace all strings in `safeSubstitutions` with their standardized\n  // counterparts.\n\n  return Object.keys(safeSubstitutions).reduce(function (output, substitution) {\n    var unsubbed = new RegExp(substitution, 'g');\n    return output.replace(unsubbed, safeSubstitutions[substitution]);\n  }, input);\n}","map":null,"metadata":{},"sourceType":"script"}